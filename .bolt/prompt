# Bolt.new 開発指針

## 1. はじめに

このドキュメントは、StackBlitzのAI生成フルスタックアプリケーションサービス **Bolt.new** を利用して構築されたWebアプリケーションを、統一的な開発指針に従って実装・拡張するためのガイドラインです。

本指針の目的は、Bolt.newによって迅速に生成されたフルスタックアプリケーションを、我々のプロジェクトで定義されたアーキテクチャ（Atomic Design）とルールに沿ってリファクタリング・実装し、一貫性と保守性の高いコードベースを維持することです。

## 2. Bolt.new利用フェーズのゴール

このフェーズの完了条件は以下の通りです：

- Bolt.newで生成されたすべての画面UIが、本指針に従ってコンポーネントとして実装されていること
- 実装されたコンポーネントにモックデータまたは実際のAPIから取得したデータが正しく表示されていること
- 静的・動的な画面遷移が問題なく動作し、ユーザー体験の全体像が確認できること
- フロントエンドとバックエンドの連携が適切に機能していること

## 3. 技術スタックと基本方針

### フロントエンド
- **フレームワーク**: React / TypeScript
- **バンドラー**: Vite
- **ルーティング**: React Router
- **状態管理**: useState, useEffect, useContext（複雑な状態管理が必要な場合のみZustandを検討）
- **データバリデーション**: Zod
- **CSS**: Tailwind CSS
- **デザインパターン**: Atomic Design
- **HTTPクライアント**: fetch API または axios

### バックエンド
- **ランタイム**: Node.js
- **フレームワーク**: Express.js
- **データベース**: 初期段階はインメモリ、後にSQLite/PostgreSQL
- **API設計**: RESTful API
- **バリデーション**: Zod（フロントエンドと共通）

### 開発環境
- **Node.jsバージョン**: 20.x以上
- **パッケージマネージャー**: pnpm
- **コード品質**: ESLint / Prettier による静的解析とフォーマット

## 4. ディレクトリ構成

Bolt.newプロジェクトの推奨ディレクトリ構成：

```
├── src/
│   ├── components/           # 共通UIコンポーネント (Atomic Design)
│   │   ├── atoms/
│   │   ├── molecules/
│   │   └── organisms/
│   ├── pages/                # ページコンポーネント
│   ├── layouts/              # レイアウトコンポーネント
│   ├── hooks/                # カスタムフック
│   ├── services/             # API通信ロジック
│   ├── utils/                # 汎用的な関数
│   ├── constants/            # 定数
│   ├── types/                # TypeScript型定義
│   ├── styles/               # グローバルCSS
│   └── mocks/                # モックデータ
├── server/                   # バックエンドコード
│   ├── routes/               # APIルート
│   ├── controllers/          # コントローラー
│   ├── models/               # データモデル
│   ├── middleware/           # ミドルウェア
│   └── utils/                # サーバーサイドユーティリティ
├── public/                   # 静的ファイル
└── docs/                     # ドキュメント
```

## 5. 🧱 Atomic Design 指針

UIコンポーネントはAtomic Designの階層に厳密に従って実装します。Bolt.newから生成されたコードは、この構造に合わせて適切に分解・再構成してください。

### 階層定義

- **Atoms**: それ以上分割できない最小単位（Button, Input, Label, Icon）
- **Molecules**: 複数のAtomで構成される機能単位（SearchForm, UserCard, NavItem）
- **Organisms**: 複数のMoleculeやAtomで構成される自立したUIセクション（Header, Sidebar, ProductList）
- **Templates**: ページのレイアウト定義（layouts/配下）
- **Pages**: 具体的なコンテンツを持つページ（pages/配下）

### 運用ルール

1. **コンポーネントの責務**: UIを構成するすべての要素は、必ずcomponents配下のコンポーネントを組み合わせて構築してください
2. **拡張と作成**: 新規UIの作成時、既存コンポーネントで対応できない場合は、まず既存の拡張を検討し、それが難しい場合に限り新規作成してください
3. **直接記述の禁止**: pages/配下やlayouts/配下に直接複雑なJSXやスタイルを記述することは原則禁止です
4. **スタイリングのルール**:
   - 意味を持つUI部品は、必ずAtomまたはMoleculeとしてコンポーネント化
   - Organismやpage内でのdivやspanへの直接のクラス指定は、レイアウト調整に限定
   - 繰り返し利用されるUIパターンは、発見次第コンポーネントとして切り出し

## 6. API実装ガイドライン

### フロントエンド API通信

```typescript
// services/api.ts
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

export const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
});

// services/userService.ts
import { api } from './api';
import { UserSchema, type User } from '@/types/user';

export const userService = {
  async getUsers(): Promise<User[]> {
    const response = await api.get('/api/users');
    return UserSchema.array().parse(response.data);
  },
  
  async getUserById(id: string): Promise<User> {
    const response = await api.get(`/users/${id}`);
    return UserSchema.parse(response.data);
  },
};
```

### バックエンド API Routes

```typescript
// server/routes/users.ts
import express from 'express';
import { UserSchema } from '../types/user';
import { users } from '../mocks/users';

const router = express.Router();

router.get('/users', (req, res) => {
  try {
    const validatedUsers = UserSchema.array().parse(users);
    res.json(validatedUsers);
  } catch (error) {
    res.status(500).json({ error: 'Data validation failed' });
  }
});

router.get('/users/:id', (req, res) => {
  try {
    const user = users.find(u => u.id === req.params.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    const validatedUser = UserSchema.parse(user);
    res.json(validatedUser);
  } catch (error) {
    res.status(500).json({ error: 'Data validation failed' });
  }
});

export default router;
```

## 7. 状態管理指針

### 基本方針
- **ローカル状態**: `useState`、`useReducer`を使用
- **グローバル状態**: `useContext` + `useReducer`、または必要に応じてZustand
- **サーバー状態**: カスタムフックでのfetch管理

### カスタムフック例

```typescript
// hooks/useUsers.ts
import { useState, useEffect } from 'react';
import { userService } from '@/services/userService';
import type { User } from '@/types/user';

export const useUsers = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const data = await userService.getUsers();
        setUsers(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  return { users, loading, error };
};
```

## 8. 型定義とバリデーション

### 共通型定義

```typescript
// types/user.ts
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  avatar: z.string().optional(),
  createdAt: z.string().datetime(),
});

export type User = z.infer<typeof UserSchema>;
```

## 9. 開発ワークフロー

### Bolt.newから既存プロジェクトへの統合手順

1. **コンポーネント分析**: 生成されたUIを Atomic Design の階層に分解
2. **型定義作成**: 必要な型をZodスキーマとして定義
3. **コンポーネント実装**: Atom → Molecule → Organism の順で実装
4. **API統合**: フロントエンドとバックエンドのAPI連携を実装
5. **テスト**: 各コンポーネントと API の動作確認
6. **リファクタリング**: コードの最適化と重複排除

### コード品質チェック

```json
// package.json scripts
{
  "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
  "lint:fix": "eslint src --ext ts,tsx --fix",
  "format": "prettier --write src/**/*.{ts,tsx}",
  "type-check": "tsc --noEmit"
}
```

## 10. 環境変数管理

```typescript
// src/config/env.ts
import { z } from 'zod';

const envSchema = z.object({
  VITE_API_BASE_URL: z.string().url(),
  VITE_APP_NAME: z.string(),
  MODE: z.enum(['development', 'production', 'test']),
});

export const env = envSchema.parse({
  VITE_API_BASE_URL: import.meta.env.VITE_API_BASE_URL,
  VITE_APP_NAME: import.meta.env.VITE_APP_NAME,
  MODE: import.meta.env.MODE,
});
```

## 11. パフォーマンス最適化

### 推奨事項
- **Code Splitting**: React.lazy と Suspense を活用
- **メモ化**: React.memo、useMemo、useCallback の適切な使用
- **バンドル最適化**: Vite の tree-shaking を活用
- **画像最適化**: WebP形式の使用、lazy loading

### 実装例

```typescript
// pages/Dashboard.tsx
import { lazy, Suspense } from 'react';
import { LoadingSpinner } from '@/components/atoms/LoadingSpinner';

const DashboardContent = lazy(() => import('@/components/organisms/DashboardContent'));

export const Dashboard = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <DashboardContent />
    </Suspense>
  );
};
```